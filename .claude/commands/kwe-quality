#!/bin/bash
# KWE Quality Command
#
# Quality assurance pipeline for Knowledge World Engine (KWE)
# Comprehensive linting, security, type checking, and code quality validation
# Following KWE architectural compliance and production standards

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
KWE_ROOT="$(dirname "$(dirname "$SCRIPT_DIR")")"
PROJECT_ROOT="$KWE_ROOT"
LOG_DIR="$KWE_ROOT/logs"
QUALITY_LOG_FILE="$LOG_DIR/kwe_quality.log"

# Quality check directories
SRC_DIRS=("src" "api" "agents" "core" "memory" "utils")
TEST_DIRS=("tests")
ALL_DIRS=("${SRC_DIRS[@]}" "${TEST_DIRS[@]}")

# Default values
DEFAULT_CHECK_TYPE="all"

# Function to log messages
log_message() {
    local level=$1
    local message=$2
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${timestamp} [${level}] ${message}" | tee -a "$QUALITY_LOG_FILE"
}

# Function to display usage
display_usage() {
    echo -e "${BLUE}KWE Quality Command - Quality Assurance Pipeline${NC}"
    echo "================================================"
    echo ""
    echo "Usage: $0 [CHECK_TYPE]"
    echo ""
    echo "Arguments:"
    echo "  CHECK_TYPE    Quality check type (lint|security|types|all) [default: all]"
    echo ""
    echo "Check Types:"
    echo "  lint      Code linting and formatting (flake8, black, isort)"
    echo "  security  Security scanning (bandit, safety)"
    echo "  types     Type checking (mypy)"
    echo "  all       Complete quality pipeline (all checks)"
    echo ""
    echo "Environment Variables:"
    echo "  \$CHECK_TYPE    Override check type"
    echo ""
    echo "Examples:"
    echo "  $0 lint               # Run linting and formatting checks"
    echo "  $0 security           # Run security scanning only"
    echo "  $0 types              # Run type checking only"
    echo "  $0 all                # Run complete quality pipeline"
    echo ""
    echo "KWE Quality Standards:"
    echo "  • PEP 8 compliance with flake8"
    echo "  • Code formatting with black (88 char line length)"
    echo "  • Import sorting with isort"
    echo "  • Type annotations with mypy strict mode"
    echo "  • Security scanning with bandit and safety"
    echo "  • Production-ready code quality"
    echo ""
}

# Function to check quality dependencies
check_quality_dependencies() {
    log_message "INFO" "Checking KWE quality dependencies..."
    
    local missing_deps=()
    
    # Check Python and Poetry
    if ! command -v python3 >/dev/null 2>&1; then
        missing_deps+=("python3")
    fi
    
    if ! command -v poetry >/dev/null 2>&1; then
        missing_deps+=("poetry")
    fi
    
    # Check quality tools
    if ! python3 -c "import flake8" 2>/dev/null; then
        missing_deps+=("flake8")
    fi
    
    if ! python3 -c "import black" 2>/dev/null; then
        missing_deps+=("black")
    fi
    
    if ! python3 -c "import isort" 2>/dev/null; then
        missing_deps+=("isort")
    fi
    
    if ! python3 -c "import mypy" 2>/dev/null; then
        missing_deps+=("mypy")
    fi
    
    if ! python3 -c "import bandit" 2>/dev/null; then
        missing_deps+=("bandit")
    fi
    
    if ! python3 -c "import safety" 2>/dev/null; then
        missing_deps+=("safety")
    fi
    
    if [ ${#missing_deps[@]} -gt 0 ]; then
        log_message "ERROR" "Missing quality dependencies: ${missing_deps[*]}"
        echo -e "${RED}❌ Missing dependencies: ${missing_deps[*]}${NC}"
        echo -e "${YELLOW}💡 Install with: poetry install --with dev${NC}"
        return 1
    fi
    
    echo -e "${GREEN}✅ All quality dependencies available${NC}"
    return 0
}

# Function to check target directories
check_target_directories() {
    log_message "INFO" "Checking KWE target directories..."
    
    local existing_dirs=()
    local missing_dirs=()
    
    for dir in "${ALL_DIRS[@]}"; do
        if [ -d "$PROJECT_ROOT/$dir" ]; then
            existing_dirs+=("$dir")
        else
            missing_dirs+=("$dir")
        fi
    done
    
    if [ ${#existing_dirs[@]} -eq 0 ]; then
        log_message "ERROR" "No target directories found"
        echo -e "${RED}❌ No target directories found${NC}"
        return 1
    fi
    
    echo -e "${GREEN}✅ Target directories: ${existing_dirs[*]}${NC}"
    
    if [ ${#missing_dirs[@]} -gt 0 ]; then
        echo -e "${YELLOW}ℹ️  Missing directories (skipped): ${missing_dirs[*]}${NC}"
    fi
    
    return 0
}

# Function to run linting checks
run_linting_checks() {
    log_message "INFO" "Running KWE linting and formatting checks..."
    echo -e "${BLUE}🔍 Running Linting and Formatting Checks${NC}"
    echo "========================================"
    
    cd "$PROJECT_ROOT"
    
    local lint_result=0
    local existing_dirs=()
    
    # Get existing directories
    for dir in "${SRC_DIRS[@]}" "${TEST_DIRS[@]}"; do
        if [ -d "$dir" ]; then
            existing_dirs+=("$dir")
        fi
    done
    
    if [ ${#existing_dirs[@]} -eq 0 ]; then
        echo -e "${YELLOW}⚠️  No source directories found for linting${NC}"
        return 1
    fi
    
    # 1. flake8 - PEP 8 compliance
    echo -e "${CYAN}1. flake8 - PEP 8 Compliance${NC}"
    echo "============================="
    
    local flake8_cmd="poetry run flake8 ${existing_dirs[*]}"
    log_message "INFO" "Executing: $flake8_cmd"
    
    if eval "$flake8_cmd"; then
        echo -e "${GREEN}✅ flake8: All checks passed${NC}"
    else
        echo -e "${RED}❌ flake8: Issues found${NC}"
        lint_result=1
    fi
    
    echo ""
    
    # 2. black - Code formatting
    echo -e "${CYAN}2. black - Code Formatting${NC}"
    echo "=========================="
    
    local black_check_cmd="poetry run black --check --diff ${existing_dirs[*]}"
    log_message "INFO" "Executing: $black_check_cmd"
    
    if eval "$black_check_cmd"; then
        echo -e "${GREEN}✅ black: Code formatting is consistent${NC}"
    else
        echo -e "${YELLOW}⚠️  black: Formatting issues found${NC}"
        echo -e "${CYAN}Auto-fixing formatting issues...${NC}"
        
        local black_fix_cmd="poetry run black ${existing_dirs[*]}"
        if eval "$black_fix_cmd"; then
            echo -e "${GREEN}✅ black: Formatting issues fixed${NC}"
        else
            echo -e "${RED}❌ black: Failed to fix formatting${NC}"
            lint_result=1
        fi
    fi
    
    echo ""
    
    # 3. isort - Import sorting
    echo -e "${CYAN}3. isort - Import Sorting${NC}"
    echo "========================"
    
    local isort_check_cmd="poetry run isort --check-only --diff ${existing_dirs[*]}"
    log_message "INFO" "Executing: $isort_check_cmd"
    
    if eval "$isort_check_cmd"; then
        echo -e "${GREEN}✅ isort: Import sorting is consistent${NC}"
    else
        echo -e "${YELLOW}⚠️  isort: Import sorting issues found${NC}"
        echo -e "${CYAN}Auto-fixing import sorting...${NC}"
        
        local isort_fix_cmd="poetry run isort ${existing_dirs[*]}"
        if eval "$isort_fix_cmd"; then
            echo -e "${GREEN}✅ isort: Import sorting fixed${NC}"
        else
            echo -e "${RED}❌ isort: Failed to fix import sorting${NC}"
            lint_result=1
        fi
    fi
    
    echo ""
    
    # Summary
    if [ $lint_result -eq 0 ]; then
        log_message "INFO" "Linting checks completed successfully"
        echo -e "${GREEN}🎉 All linting checks passed${NC}"
    else
        log_message "WARN" "Linting checks completed with issues"
        echo -e "${YELLOW}⚠️  Linting completed with issues${NC}"
    fi
    
    return $lint_result
}

# Function to run security checks
run_security_checks() {
    log_message "INFO" "Running KWE security scanning..."
    echo -e "${BLUE}🔒 Running Security Checks${NC}"
    echo "========================="
    
    cd "$PROJECT_ROOT"
    
    local security_result=0
    local existing_dirs=()
    
    # Get existing source directories (exclude tests for security)
    for dir in "${SRC_DIRS[@]}"; do
        if [ -d "$dir" ]; then
            existing_dirs+=("$dir")
        fi
    done
    
    if [ ${#existing_dirs[@]} -eq 0 ]; then
        echo -e "${YELLOW}⚠️  No source directories found for security scanning${NC}"
        return 1
    fi
    
    # 1. bandit - Security issues in Python code
    echo -e "${CYAN}1. bandit - Python Security Scanner${NC}"
    echo "=================================="
    
    local bandit_cmd="poetry run bandit -r ${existing_dirs[*]} -f json -o bandit-report.json"
    log_message "INFO" "Executing: $bandit_cmd"
    
    if eval "$bandit_cmd" 2>/dev/null; then
        echo -e "${GREEN}✅ bandit: No security issues found${NC}"
        
        # Display summary if report exists
        if [ -f "bandit-report.json" ]; then
            local issue_count=$(python3 -c "
import json
try:
    with open('bandit-report.json', 'r') as f:
        data = json.load(f)
        print(len(data.get('results', [])))
except:
    print('0')
" 2>/dev/null)
            echo -e "${CYAN}📊 Security issues found: $issue_count${NC}"
        fi
    else
        echo -e "${YELLOW}⚠️  bandit: Security issues detected${NC}"
        echo -e "${CYAN}📄 Report saved: bandit-report.json${NC}"
        security_result=1
    fi
    
    echo ""
    
    # 2. safety - Known security vulnerabilities in dependencies
    echo -e "${CYAN}2. safety - Dependency Security Scanner${NC}"
    echo "======================================"
    
    local safety_cmd="poetry run safety check --json --output safety-report.json"
    log_message "INFO" "Executing: $safety_cmd"
    
    if eval "$safety_cmd" 2>/dev/null; then
        echo -e "${GREEN}✅ safety: No known vulnerabilities in dependencies${NC}"
    else
        echo -e "${YELLOW}⚠️  safety: Known vulnerabilities found in dependencies${NC}"
        echo -e "${CYAN}📄 Report saved: safety-report.json${NC}"
        
        # Try to show summary
        if [ -f "safety-report.json" ]; then
            echo -e "${CYAN}💡 Run 'poetry update' to fix known vulnerabilities${NC}"
        fi
        security_result=1
    fi
    
    echo ""
    
    # 3. Additional security checks
    echo -e "${CYAN}3. Additional Security Validation${NC}"
    echo "================================"
    
    # Check for common security anti-patterns
    local security_patterns=0
    
    echo -e "${CYAN}Checking for security anti-patterns...${NC}"
    
    # Check for hardcoded secrets (basic patterns)
    local secret_files=$(grep -r -l "password\s*=\s*['\"][^'\"]*['\"]" "${existing_dirs[@]}" 2>/dev/null || true)
    if [ -n "$secret_files" ]; then
        echo -e "${YELLOW}⚠️  Potential hardcoded passwords found${NC}"
        ((security_patterns++))
    fi
    
    # Check for SQL injection patterns
    local sql_files=$(grep -r -l "execute.*%\|format.*INSERT\|format.*SELECT" "${existing_dirs[@]}" 2>/dev/null || true)
    if [ -n "$sql_files" ]; then
        echo -e "${YELLOW}⚠️  Potential SQL injection patterns found${NC}"
        ((security_patterns++))
    fi
    
    # Check for debug/test code in production
    local debug_files=$(grep -r -l "DEBUG\s*=\s*True\|print(" "${existing_dirs[@]}" 2>/dev/null || true)
    if [ -n "$debug_files" ]; then
        echo -e "${YELLOW}⚠️  Debug code found (review for production)${NC}"
        ((security_patterns++))
    fi
    
    if [ $security_patterns -eq 0 ]; then
        echo -e "${GREEN}✅ No security anti-patterns detected${NC}"
    else
        echo -e "${YELLOW}⚠️  $security_patterns potential security issues found${NC}"
        security_result=1
    fi
    
    echo ""
    
    # Summary
    if [ $security_result -eq 0 ]; then
        log_message "INFO" "Security checks completed successfully"
        echo -e "${GREEN}🔒 All security checks passed${NC}"
    else
        log_message "WARN" "Security checks completed with issues"
        echo -e "${YELLOW}⚠️  Security checks completed with issues${NC}"
        echo -e "${CYAN}📄 Review reports: bandit-report.json, safety-report.json${NC}"
    fi
    
    return $security_result
}

# Function to run type checking
run_type_checking() {
    log_message "INFO" "Running KWE type checking..."
    echo -e "${BLUE}🔧 Running Type Checking${NC}"
    echo "======================="
    
    cd "$PROJECT_ROOT"
    
    local type_result=0
    local existing_dirs=()
    
    # Get existing source directories (exclude tests for strict type checking)
    for dir in "${SRC_DIRS[@]}"; do
        if [ -d "$dir" ]; then
            existing_dirs+=("$dir")
        fi
    done
    
    if [ ${#existing_dirs[@]} -eq 0 ]; then
        echo -e "${YELLOW}⚠️  No source directories found for type checking${NC}"
        return 1
    fi
    
    # mypy - Static type checking
    echo -e "${CYAN}mypy - Static Type Checking${NC}"
    echo "=========================="
    
    local mypy_cmd="poetry run mypy ${existing_dirs[*]} --ignore-missing-imports --show-error-codes --show-error-context"
    log_message "INFO" "Executing: $mypy_cmd"
    
    echo -e "${CYAN}Running mypy with strict configuration...${NC}"
    
    if eval "$mypy_cmd"; then
        echo -e "${GREEN}✅ mypy: All type checks passed${NC}"
        
        # Count total files checked
        local file_count=$(find "${existing_dirs[@]}" -name "*.py" | wc -l)
        echo -e "${CYAN}📊 Files checked: $file_count Python files${NC}"
    else
        echo -e "${YELLOW}⚠️  mypy: Type checking issues found${NC}"
        
        # Try to provide summary
        echo -e "${CYAN}💡 Common fixes:${NC}"
        echo -e "${CYAN}  • Add type annotations to function parameters and returns${NC}"
        echo -e "${CYAN}  • Use Optional[Type] for nullable parameters${NC}"
        echo -e "${CYAN}  • Import types from typing module${NC}"
        echo -e "${CYAN}  • Use # type: ignore for unavoidable issues${NC}"
        
        type_result=1
    fi
    
    echo ""
    
    # Additional type analysis
    echo -e "${CYAN}Additional Type Analysis${NC}"
    echo "======================="
    
    local type_stats=0
    
    # Count functions without type annotations
    local untyped_functions=$(grep -r "^def \|^async def " "${existing_dirs[@]}" | grep -v " -> " | wc -l)
    local total_functions=$(grep -r "^def \|^async def " "${existing_dirs[@]}" | wc -l)
    
    if [ $total_functions -gt 0 ]; then
        local typed_percentage=$(( (total_functions - untyped_functions) * 100 / total_functions ))
        echo -e "${CYAN}📊 Type annotation coverage: ${typed_percentage}% ($((total_functions - untyped_functions))/$total_functions functions)${NC}"
        
        if [ $typed_percentage -lt 80 ]; then
            echo -e "${YELLOW}⚠️  Low type annotation coverage (target: 80%+)${NC}"
            type_result=1
        else
            echo -e "${GREEN}✅ Good type annotation coverage${NC}"
        fi
    fi
    
    # Check for Any usage (should be minimized)
    local any_usage=$(grep -r "Any\|typing.Any" "${existing_dirs[@]}" | wc -l)
    if [ $any_usage -gt 0 ]; then
        echo -e "${CYAN}📊 'Any' type usage: $any_usage occurrences${NC}"
        if [ $any_usage -gt 10 ]; then
            echo -e "${YELLOW}⚠️  High 'Any' usage - consider more specific types${NC}"
        fi
    fi
    
    echo ""
    
    # Summary
    if [ $type_result -eq 0 ]; then
        log_message "INFO" "Type checking completed successfully"
        echo -e "${GREEN}🔧 All type checks passed${NC}"
    else
        log_message "WARN" "Type checking completed with issues"
        echo -e "${YELLOW}⚠️  Type checking completed with issues${NC}"
    fi
    
    return $type_result
}

# Function to run all quality checks
run_all_checks() {
    log_message "INFO" "Running complete KWE quality pipeline..."
    echo -e "${BLUE}🚀 Running Complete Quality Pipeline${NC}"
    echo "===================================="
    
    local pipeline_start_time=$(date +%s)
    local total_result=0
    local check_results=()
    
    # Phase 1: Linting and Formatting
    echo -e "${CYAN}Phase 1: Linting and Formatting${NC}"
    echo "==============================="
    
    if run_linting_checks; then
        check_results+=("✅ Linting")
    else
        check_results+=("❌ Linting")
        total_result=1
    fi
    
    echo ""
    
    # Phase 2: Security Scanning
    echo -e "${CYAN}Phase 2: Security Scanning${NC}"
    echo "=========================="
    
    if run_security_checks; then
        check_results+=("✅ Security")
    else
        check_results+=("⚠️  Security")
        # Don't fail pipeline for security warnings, but log them
    fi
    
    echo ""
    
    # Phase 3: Type Checking
    echo -e "${CYAN}Phase 3: Type Checking${NC}"
    echo "======================"
    
    if run_type_checking; then
        check_results+=("✅ Types")
    else
        check_results+=("⚠️  Types")
        # Don't fail pipeline for type issues in development
    fi
    
    echo ""
    
    # Phase 4: Quality Metrics Summary
    echo -e "${CYAN}Phase 4: Quality Metrics Summary${NC}"
    echo "==============================="
    
    cd "$PROJECT_ROOT"
    
    # Calculate overall metrics
    local total_files=$(find "${SRC_DIRS[@]}" -name "*.py" 2>/dev/null | wc -l)
    local total_lines=$(find "${SRC_DIRS[@]}" -name "*.py" -exec wc -l {} + 2>/dev/null | tail -1 | awk '{print $1}' || echo "0")
    local total_functions=$(grep -r "^def \|^async def " "${SRC_DIRS[@]}" 2>/dev/null | wc -l)
    local total_classes=$(grep -r "^class " "${SRC_DIRS[@]}" 2>/dev/null | wc -l)
    
    echo -e "${CYAN}📊 Codebase Metrics:${NC}"
    echo -e "${CYAN}  Python files: $total_files${NC}"
    echo -e "${CYAN}  Lines of code: $total_lines${NC}"
    echo -e "${CYAN}  Functions: $total_functions${NC}"
    echo -e "${CYAN}  Classes: $total_classes${NC}"
    
    # Calculate pipeline time
    local pipeline_end_time=$(date +%s)
    local pipeline_duration=$((pipeline_end_time - pipeline_start_time))
    local pipeline_minutes=$((pipeline_duration / 60))
    local pipeline_seconds=$((pipeline_duration % 60))
    
    echo ""
    echo -e "${CYAN}📈 Quality Pipeline Results:${NC}"
    for result in "${check_results[@]}"; do
        echo -e "  $result${NC}"
    done
    
    echo ""
    echo -e "${CYAN}⏱️  Pipeline completed in ${pipeline_minutes}m ${pipeline_seconds}s${NC}"
    
    # Final assessment
    if [ $total_result -eq 0 ]; then
        log_message "INFO" "Complete quality pipeline passed"
        echo -e "${GREEN}🎉 Quality pipeline completed successfully${NC}"
    else
        log_message "WARN" "Quality pipeline completed with issues"
        echo -e "${YELLOW}⚠️  Quality pipeline completed with issues${NC}"
    fi
    
    return $total_result
}

# Function to display quality summary
display_quality_summary() {
    local check_type=$1
    local result=$2
    
    echo ""
    echo "====================================="
    if [ $result -eq 0 ]; then
        echo -e "${GREEN}🎉 KWE Quality $check_type Completed Successfully${NC}"
        echo ""
        echo -e "${CYAN}Quality Results:${NC}"
        echo -e "${CYAN}  Check Type: $check_type${NC}"
        echo -e "${CYAN}  Status: PASSED${NC}"
        echo ""
        echo -e "${CYAN}KWE Quality Standards:${NC}"
        echo -e "${CYAN}  ✅ PEP 8 Compliance${NC}"
        echo -e "${CYAN}  ✅ Code Formatting (Black)${NC}"
        echo -e "${CYAN}  ✅ Import Organization (isort)${NC}"
        echo -e "${CYAN}  ✅ Type Safety (mypy)${NC}"
        echo -e "${CYAN}  ✅ Security Scanning${NC}"
        echo -e "${CYAN}  ✅ Production-Ready Quality${NC}"
    else
        echo -e "${RED}❌ KWE Quality $check_type Failed or Has Issues${NC}"
        echo ""
        echo -e "${YELLOW}💡 Quality Improvement Actions:${NC}"
        echo -e "${YELLOW}  1. Review quality logs: $QUALITY_LOG_FILE${NC}"
        echo -e "${YELLOW}  2. Fix linting issues: poetry run flake8 src/${NC}"
        echo -e "${YELLOW}  3. Format code: poetry run black src/${NC}"
        echo -e "${YELLOW}  4. Sort imports: poetry run isort src/${NC}"
        echo -e "${YELLOW}  5. Add type annotations: poetry run mypy src/${NC}"
        echo -e "${YELLOW}  6. Review security reports: bandit-report.json${NC}"
    fi
    echo ""
}

# Main execution
main() {
    local check_type="${1:-${CHECK_TYPE:-$DEFAULT_CHECK_TYPE}}"
    
    # Validate arguments
    case "$check_type" in
        lint|security|types|all)
            ;;
        -h|--help)
            display_usage
            exit 0
            ;;
        *)
            echo -e "${RED}❌ Invalid check type: $check_type${NC}"
            echo -e "${YELLOW}Valid options: lint, security, types, all${NC}"
            display_usage
            exit 1
            ;;
    esac
    
    echo -e "${BLUE}🔍 KWE Quality Assurance System${NC}"
    echo "==============================="
    echo -e "${CYAN}Check Type: $check_type${NC}"
    echo ""
    
    # Setup logging
    mkdir -p "$LOG_DIR"
    log_message "INFO" "Starting KWE quality assurance: $check_type"
    
    # Check dependencies
    if ! check_quality_dependencies; then
        exit 1
    fi
    
    # Check target directories
    if ! check_target_directories; then
        exit 1
    fi
    
    # Run quality checks based on type
    local quality_result=0
    case "$check_type" in
        lint)
            run_linting_checks || quality_result=1
            ;;
        security)
            run_security_checks || quality_result=1
            ;;
        types)
            run_type_checking || quality_result=1
            ;;
        all)
            run_all_checks || quality_result=1
            ;;
    esac
    
    # Display summary
    display_quality_summary "$check_type" "$quality_result"
    
    exit $quality_result
}

# Run main function
main "$@"