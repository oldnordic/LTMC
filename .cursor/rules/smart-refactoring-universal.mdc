description: Universal smart refactoring rules that apply to all programming languages
tags: [refactoring, quality, best-practices, universal]
priority: highest
alwaysApply: true
---

# Smart Refactoring Rules - Universal Principles

## 🚫 FORBIDDEN APPROACHES (Never Use These)

### Quick Fixes That Mask Problems
- ❌ **NEVER use lint disable comments** (`// eslint-disable`, `# noqa`, `@SuppressWarnings`)
- ❌ **NEVER use global ignore rules** for code quality issues
- ❌ **NEVER artificially break lines** just to meet length limits
- ❌ **NEVER add meaningless variable assignments** to satisfy unused variable warnings
- ❌ **NEVER use any/Object/unknown types** to avoid type errors
- ❌ **NEVER catch and ignore exceptions** without proper handling

### Why These Are Forbidden
These approaches:
- Hide underlying code quality issues
- Create technical debt
- Make debugging harder
- Reduce maintainability
- Set bad precedents for the team
- Mask architectural problems

## ✅ REQUIRED APPROACHES (Always Use These)

### 1. Root Cause Analysis
**ALWAYS ask: "Why is this error occurring?"**
- Line too long → Function is too complex, needs extraction
- Unused variable → Logic is incomplete or variable is unnecessary
- Deep nesting → Control flow needs restructuring
- Type errors → Data flow needs clarification
- Import errors → Architecture needs improvement

### 2. Structural Improvements
**ALWAYS improve code structure to solve problems:**
- Extract methods/functions to reduce complexity
- Use early returns to reduce nesting
- Break up large classes/modules
- Improve naming for clarity
- Simplify control flow
- Enhance error handling

### 3. Single Responsibility Principle
**EVERY function/method should do ONE thing well:**
- If a function is too long → Split into multiple focused functions
- If a class has many responsibilities → Extract separate classes
- If a file has mixed concerns → Separate into focused modules

## 🔧 LANGUAGE-SPECIFIC SMART REFACTORING RULES

### When Cursor encounters ANY linting/quality issue:
1. **Analyze the root cause** of the issue
2. **Propose structural improvements** that solve the underlying problem
3. **Extract reusable components** where appropriate
4. **Improve naming and clarity**
5. **Maintain or enhance functionality** while fixing the issue
6. **Add proper documentation** to new components

## DECISION FRAMEWORK

When encountering a code quality issue, Cursor must follow this decision tree:

```
Issue Detected
    ↓
Is this a symptom of a deeper structural problem?
    ↓ YES
Identify the root cause
    ↓
Propose structural refactoring
    ↓
Extract methods/classes/modules as needed
    ↓
Improve naming and documentation
    ↓
Verify functionality is maintained
    ↓
Apply the refactoring

    ↓ NO (simple surface issue)
Apply minimal, clean fix
    ↓
Ensure fix doesn't introduce technical debt
```

## MANDATORY REFACTORING PATTERNS

### Pattern 1: Deep Nesting → Early Returns + Method Extraction
```
BEFORE (any language):
function complexLogic() {
    if (condition1) {
        if (condition2) {
            if (condition3) {
                // Deep nesting causes line length issues
                let result = someVeryLongFunctionCall(param1, param2, param3);
                return result;
            }
        }
    }
}

AFTER (refactored):
function complexLogic() {
    if (!condition1) return handleNoCondition1();
    if (!condition2) return null;

    return processWithCondition3();
}

function handleNoCondition1() {
    // Handle this case
}

function processWithCondition3() {
    if (!condition3) return null;

    return someVeryLongFunctionCall(
        param1,
        param2,
        param3
    );
}
```

### Pattern 2: Long Parameter Lists → Configuration Objects
```
BEFORE:
function createUser(name, email, age, address, phone, preferences, settings, metadata) {
    // Implementation
}

AFTER:
function createUser(userConfig) {
    const { name, email, age, address, phone, preferences, settings, metadata } = userConfig;
    // Implementation
}
```

### Pattern 3: Complex Conditions → Named Functions
```
BEFORE:
if (user.age >= 18 && user.hasValidEmail && user.isVerified && !user.isBanned) {
    // Complex condition logic
}

AFTER:
if (isEligibleUser(user)) {
    // Clean, readable logic
}

function isEligibleUser(user) {
    return user.age >= 18 &&
           user.hasValidEmail &&
           user.isVerified &&
           !user.isBanned;
}
```

## QUALITY METRICS TO MAINTAIN

After ANY refactoring, ensure:
- ✅ **Cyclomatic complexity** is reduced or maintained
- ✅ **Function/method length** is under reasonable limits
- ✅ **Nesting depth** is maximum 3 levels
- ✅ **Parameter count** is under 5 per function
- ✅ **Class/module size** is manageable
- ✅ **Code duplication** is eliminated
- ✅ **Naming** is clear and descriptive
```
