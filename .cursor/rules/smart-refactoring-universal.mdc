description: Universal smart refactoring rules that apply to all programming languages
tags: [refactoring, quality, best-practices, universal]
priority: highest
alwaysApply: true
---

# Smart Refactoring Rules - Universal Principles

## ðŸš« FORBIDDEN APPROACHES (Never Use These)

### Quick Fixes That Mask Problems
- âŒ **NEVER use lint disable comments** (`// eslint-disable`, `# noqa`, `@SuppressWarnings`)
- âŒ **NEVER use global ignore rules** for code quality issues
- âŒ **NEVER artificially break lines** just to meet length limits
- âŒ **NEVER add meaningless variable assignments** to satisfy unused variable warnings
- âŒ **NEVER use any/Object/unknown types** to avoid type errors
- âŒ **NEVER catch and ignore exceptions** without proper handling

### Why These Are Forbidden
These approaches:
- Hide underlying code quality issues
- Create technical debt
- Make debugging harder
- Reduce maintainability
- Set bad precedents for the team
- Mask architectural problems

## âœ… REQUIRED APPROACHES (Always Use These)

### 1. Root Cause Analysis
**ALWAYS ask: "Why is this error occurring?"**
- Line too long â†’ Function is too complex, needs extraction
- Unused variable â†’ Logic is incomplete or variable is unnecessary
- Deep nesting â†’ Control flow needs restructuring
- Type errors â†’ Data flow needs clarification
- Import errors â†’ Architecture needs improvement

### 2. Structural Improvements
**ALWAYS improve code structure to solve problems:**
- Extract methods/functions to reduce complexity
- Use early returns to reduce nesting
- Break up large classes/modules
- Improve naming for clarity
- Simplify control flow
- Enhance error handling

### 3. Single Responsibility Principle
**EVERY function/method should do ONE thing well:**
- If a function is too long â†’ Split into multiple focused functions
- If a class has many responsibilities â†’ Extract separate classes
- If a file has mixed concerns â†’ Separate into focused modules

## ðŸ”§ LANGUAGE-SPECIFIC SMART REFACTORING RULES

### When Cursor encounters ANY linting/quality issue:
1. **Analyze the root cause** of the issue
2. **Propose structural improvements** that solve the underlying problem
3. **Extract reusable components** where appropriate
4. **Improve naming and clarity**
5. **Maintain or enhance functionality** while fixing the issue
6. **Add proper documentation** to new components

## DECISION FRAMEWORK

When encountering a code quality issue, Cursor must follow this decision tree:

```
Issue Detected
    â†“
Is this a symptom of a deeper structural problem?
    â†“ YES
Identify the root cause
    â†“
Propose structural refactoring
    â†“
Extract methods/classes/modules as needed
    â†“
Improve naming and documentation
    â†“
Verify functionality is maintained
    â†“
Apply the refactoring

    â†“ NO (simple surface issue)
Apply minimal, clean fix
    â†“
Ensure fix doesn't introduce technical debt
```

## MANDATORY REFACTORING PATTERNS

### Pattern 1: Deep Nesting â†’ Early Returns + Method Extraction
```
BEFORE (any language):
function complexLogic() {
    if (condition1) {
        if (condition2) {
            if (condition3) {
                // Deep nesting causes line length issues
                let result = someVeryLongFunctionCall(param1, param2, param3);
                return result;
            }
        }
    }
}

AFTER (refactored):
function complexLogic() {
    if (!condition1) return handleNoCondition1();
    if (!condition2) return null;

    return processWithCondition3();
}

function handleNoCondition1() {
    // Handle this case
}

function processWithCondition3() {
    if (!condition3) return null;

    return someVeryLongFunctionCall(
        param1,
        param2,
        param3
    );
}
```

### Pattern 2: Long Parameter Lists â†’ Configuration Objects
```
BEFORE:
function createUser(name, email, age, address, phone, preferences, settings, metadata) {
    // Implementation
}

AFTER:
function createUser(userConfig) {
    const { name, email, age, address, phone, preferences, settings, metadata } = userConfig;
    // Implementation
}
```

### Pattern 3: Complex Conditions â†’ Named Functions
```
BEFORE:
if (user.age >= 18 && user.hasValidEmail && user.isVerified && !user.isBanned) {
    // Complex condition logic
}

AFTER:
if (isEligibleUser(user)) {
    // Clean, readable logic
}

function isEligibleUser(user) {
    return user.age >= 18 &&
           user.hasValidEmail &&
           user.isVerified &&
           !user.isBanned;
}
```

## QUALITY METRICS TO MAINTAIN

After ANY refactoring, ensure:
- âœ… **Cyclomatic complexity** is reduced or maintained
- âœ… **Function/method length** is under reasonable limits
- âœ… **Nesting depth** is maximum 3 levels
- âœ… **Parameter count** is under 5 per function
- âœ… **Class/module size** is manageable
- âœ… **Code duplication** is eliminated
- âœ… **Naming** is clear and descriptive
```
