---
description: AI-powered code analysis and refactoring rules
tags: [ai, refactoring, analysis, optimization, firstspirit]
version: "1.0"
---

# AI Code Analysis and Refactoring Rules

## Code Analysis Pipeline
```python
class FirstSpiritCodeAnalyzer:
    def __init__(self):
        self.analyzers = [
            StructureAnalyzer(),
            SecurityAnalyzer(), 
            PerformanceAnalyzer(),
            FirstSpiritPatternAnalyzer(),
            DependencyAnalyzer(),
            DocumentationAnalyzer()
        ]
    
    async def analyze_module(self, module_path: str) -> ModuleAnalysis:
        """Comprehensive module analysis"""
        
        # 1. Parse module structure
        structure = await self.parse_module_structure(module_path)
        
        # 2. Run all analyzers
        analysis_results = {}
        for analyzer in self.analyzers:
            try:
                result = await analyzer.analyze(module_path, structure)
                analysis_results[analyzer.name] = result
            except Exception as e:
                logger.error(f"Analyzer {analyzer.name} failed: {e}")
        
        # 3. Generate comprehensive report
        return self.generate_analysis_report(analysis_results)
    
    async def generate_refactoring_suggestions(self, analysis: ModuleAnalysis) -> List[RefactoringSuggestion]:
        """Generate AI-powered refactoring suggestions"""
        
        suggestions = []
        
        # Security improvements
        if analysis.security.vulnerabilities:
            for vuln in analysis.security.vulnerabilities:
                suggestion = await self.generate_security_fix(vuln)
                suggestions.append(suggestion)
        
        # Performance optimizations
        if analysis.performance.issues:
            for issue in analysis.performance.issues:
                suggestion = await self.generate_performance_fix(issue)
                suggestions.append(suggestion)
        
        # FirstSpirit best practices
        if analysis.firstspirit.violations:
            for violation in analysis.firstspirit.violations:
                suggestion = await self.generate_firstspirit_fix(violation)
                suggestions.append(suggestion)
        
        return suggestions
```

## FirstSpirit Pattern Analysis
```python
class FirstSpiritPatternAnalyzer:
    """Analyze FirstSpirit-specific patterns and conventions"""
    
    def __init__(self):
        self.patterns = {
            'input_component': self.analyze_input_component,
            'output_component': self.analyze_output_component,
            'section_template': self.analyze_section_template,
            'page_template': self.analyze_page_template,
            'workflow': self.analyze_workflow,
            'module': self.analyze_module_structure
        }
    
    async def analyze_input_component(self, code: str, ast_tree) -> ComponentAnalysis:
        """Analyze input component implementation"""
        
        issues = []
        recommendations = []
        
        # Check inheritance
        if not self.extends_abstract_editor_value(ast_tree):
            issues.append(Issue(
                type="inheritance",
                severity="error", 
                message="Input component must extend AbstractEditorValue",
                line=self.find_class_declaration_line(ast_tree)
            ))
        
        # Check required methods
        required_methods = ['doEdit', 'getValue', 'aspects']
        for method in required_methods:
            if not self.has_method(ast_tree, method):
                issues.append(Issue(
                    type="missing_method",
                    severity="error",
                    message=f"Missing required method: {method}",
                    suggestion=self.generate_method_template(method)
                ))
        
        # Check error handling
        if not self.has_proper_error_handling(ast_tree):
            recommendations.append(Recommendation(
                type="error_handling",
                message="Add proper exception handling in doEdit method",
                code_example=self.get_error_handling_template()
            ))
        
        return ComponentAnalysis(
            component_type="input_component",
            issues=issues,
            recommendations=recommendations,
            quality_score=self.calculate_quality_score(issues, recommendations)
        )
    
    def get_error_handling_template(self) -> str:
        return '''
try {
    // Component logic here
} catch (Exception e) {
    LOGGER.error("Error in component operation", e);
    throw new RuntimeException("Component operation failed", e);
}
'''
```

## AI-Powered Code Generation
```python
class FirstSpiritCodeGenerator:
    """Generate FirstSpirit code using AI with specific rules"""
    
    def __init__(self, ollama_client):
        self.ollama_client = ollama_client
        self.templates = FirstSpiritTemplates()
        self.rules = self.load_generation_rules()
    
    async def generate_module_skeleton(self, requirements: ModuleRequirements) -> ModuleStructure:
        """Generate complete module structure based on requirements"""
        
        # Generate AI prompt with FirstSpirit context
        prompt = self.build_generation_prompt(requirements)
        
        # Get AI response
        ai_response = await self.ollama_client.generate(prompt)
        
        # Parse and validate response
        module_structure = self.parse_ai_response(ai_response)
        
        # Apply FirstSpirit rules and validation
        validated_structure = self.validate_and_fix_structure(module_structure)
        
        return validated_structure
    
    def build_generation_prompt(self, requirements: ModuleRequirements) -> str:
        """Build comprehensive prompt for module generation"""
        
        context = f"""
You are an expert FirstSpirit developer. Generate a complete FirstSpirit module based on these requirements:

MODULE REQUIREMENTS:
- Name: {requirements.name}
- Type: {requirements.type}
- Description: {requirements.description}
- Target FirstSpirit Version: {requirements.firstspirit_version}
- Required Components: {', '.join(requirements.components)}
- Integration Points: {', '.join(requirements.integrations)}

FIRSTSPIRIT RULES TO FOLLOW:
{self.get_firstspirit_rules()}

GENERATE:
1. Complete module structure with all necessary files
2. Java classes following FirstSpirit patterns
3. Module descriptor (module.xml)
4. Configuration files
5. Documentation and README

ENSURE:
- Proper error handling and logging
- FirstSpirit API best practices
- Security considerations
- Performance optimization
- Comprehensive documentation
"""
        
        return context
    
    def get_firstspirit_rules(self) -> str:
        return """
- All components must extend appropriate FirstSpirit base classes
- Use proper FirstSpirit APIs for content access
- Implement comprehensive error handling
- Include proper logging with SLF4J
- Follow FirstSpirit naming conventions
- Ensure thread safety for concurrent access
- Handle resource cleanup properly
- Include proper JavaDoc documentation
- Use FirstSpirit dependency injection where applicable
- Implement proper permission checks
"""
```

## Refactoring Suggestion Engine
```python
class RefactoringSuggestionEngine:
    """Generate intelligent refactoring suggestions"""
    
    async def suggest_improvements(self, code_analysis: CodeAnalysis) -> List[RefactoringSuggestion]:
        """Generate comprehensive improvement suggestions"""
        
        suggestions = []
        
        # Performance improvements
        for issue in code_analysis.performance_issues:
            suggestion = await self.generate_performance_suggestion(issue)
            suggestions.append(suggestion)
        
        # Security improvements  
        for vulnerability in code_analysis.security_vulnerabilities:
            suggestion = await self.generate_security_suggestion(vulnerability)
            suggestions.append(suggestion)
        
        # Code quality improvements
        for smell in code_analysis.code_smells:
            suggestion = await self.generate_quality_suggestion(smell)
            suggestions.append(suggestion)
        
        # FirstSpirit-specific improvements
        for violation in code_analysis.firstspirit_violations:
            suggestion = await self.generate_firstspirit_suggestion(violation)
            suggestions.append(suggestion)
        
        return self.prioritize_suggestions(suggestions)
    
    async def generate_performance_suggestion(self, issue: PerformanceIssue) -> RefactoringSuggestion:
        """Generate performance improvement suggestion"""
        
        if issue.type == "inefficient_query":
            return RefactoringSuggestion(
                id=f"perf_{issue.id}",
                title="Optimize database query",
                description=f"Query at line {issue.line} can be optimized",
                severity="medium",
                category="performance",
                before_code=issue.code_snippet,
                after_code=await self.generate_optimized_query(issue.code_snippet),
                explanation="Use prepared statements and limit result sets for better performance",
                estimated_impact="20-50% performance improvement"
            )
        
        elif issue.type == "memory_leak":
            return RefactoringSuggestion(
                id=f"perf_{issue.id}",
                title="Fix potential memory leak", 
                description=f"Resource not properly closed at line {issue.line}",
                severity="high",
                category="performance",
                before_code=issue.code_snippet,
                after_code=await self.generate_resource_cleanup(issue.code_snippet),
                explanation="Always close resources in finally blocks or use try-with-resources",
                estimated_impact="Prevents memory leaks and improves stability"
            )
```
```
