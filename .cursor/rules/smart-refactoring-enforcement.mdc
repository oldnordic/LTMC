---
description: Enforcement rules that ensure smart refactoring is always applied
tags: [enforcement, quality, mandatory]
priority: highest
alwaysApply: true
---

# Smart Refactoring Enforcement Rules

## üõ°Ô∏è MANDATORY DECISION PROCESS

When Cursor AI encounters ANY code quality issue, it MUST follow this process:

### Step 1: Issue Analysis
```
REQUIRED QUESTIONS:
1. What is the root cause of this issue?
2. Is this a symptom of a deeper structural problem?
3. What would a senior developer do to fix this properly?
4. How can we improve the code while fixing the issue?
```

### Step 2: Solution Evaluation
```
EVALUATE SOLUTIONS IN THIS ORDER:
1. ‚úÖ Structural refactoring that improves overall quality
2. ‚úÖ Method/function extraction for better organization
3. ‚úÖ Type safety and error handling improvements
4. ‚úÖ Naming and clarity enhancements
5. ‚ùå Quick fixes that hide the problem (FORBIDDEN)
```

### Step 3: Quality Verification
```
AFTER ANY CHANGE, VERIFY:
‚úÖ Code is more readable and maintainable
‚úÖ Functionality is preserved or enhanced
‚úÖ No technical debt was introduced
‚úÖ Future developers will thank us for this change
‚úÖ The fix addresses the root cause, not just symptoms
```

## üö® AUTOMATIC REJECTION CRITERIA

Cursor AI must AUTOMATICALLY REJECT any solution that:
- Uses lint disable comments (`# noqa`, `// eslint-disable`, etc.)
- Adds meaningless code to satisfy tools
- Catches and ignores exceptions
- Uses any/unknown/Object types to avoid type checking
- Creates artificial line breaks that hurt readability
- Introduces global variables to avoid proper architecture
- Uses magic numbers or strings without explanation

## üéØ SUCCESS CRITERIA

Every refactoring must achieve AT LEAST ONE of these improvements:
- ‚úÖ **Reduced complexity**: Simpler logic flow
- ‚úÖ **Better separation of concerns**: Single responsibility
- ‚úÖ **Improved readability**: Clearer intent
- ‚úÖ **Enhanced maintainability**: Easier to modify
- ‚úÖ **Better error handling**: More robust error management
- ‚úÖ **Type safety**: Better type checking and validation
- ‚úÖ **Performance improvement**: More efficient execution
- ‚úÖ **Testability**: Easier to unit test

## üìù DOCUMENTATION REQUIREMENTS

For ANY refactoring, Cursor AI must:
1. **Explain the root cause** of the original issue
2. **Describe the structural improvement** being made
3. **Show before/after** code examples
4. **Highlight the benefits** of the new approach
5. **Confirm functionality preservation**

## üîÑ ITERATIVE IMPROVEMENT

When refactoring:
1. **Start with the biggest impact change** first
2. **Break large refactoring into smaller steps**
3. **Test after each step** to ensure functionality
4. **Continuously improve** code organization
5. **Document patterns** for future reference

## üí° LEARNING AND ADAPTATION

Cursor AI should:
- **Remember successful patterns** and apply them consistently
- **Learn from code style** in the existing codebase
- **Adapt to project conventions** while maintaining quality
- **Suggest architectural improvements** when patterns emerge
- **Proactively identify** similar issues in other files

This approach ensures that every code change makes the codebase better, not just "compliant".
```
