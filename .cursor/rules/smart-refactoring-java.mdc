---
description: Java-specific smart refactoring rules for FirstSpirit development
tags: [java, firstspirit, refactoring, quality]
globs: ["**/*.java"]
---

# Smart Refactoring Rules - Java (FirstSpirit)

## JAVA-SPECIFIC ANTI-PATTERNS TO AVOID

### ❌ Never Use These Java "Quick Fixes"
```java
// BAD: Suppressing warnings instead of fixing issues
@SuppressWarnings("unchecked")
public List<String> getItems() {
    return (List<String>) rawList;  // Unsafe cast
}

// BAD: Overly long method names to stuff parameters
public void createFirstSpiritInputComponentWithValidationAndErrorHandlingAndLoggingAndCaching(String name, String type, boolean validate) {
    // Method doing too many things
}

// BAD: God classes with too many responsibilities
public class FirstSpiritManager {
    // 50+ methods doing everything
}
```

## ✅ REQUIRED JAVA REFACTORING PATTERNS

### 1. Long Methods → Extract Method + Strategy Pattern
```java
// BEFORE: Long method with multiple responsibilities
public class InputComponentProcessor {
    public void processComponent(Component component) {
        // Validation logic (20 lines)
        if (component.getName() == null || component.getName().isEmpty()) {
            throw new IllegalArgumentException("Name required");
        }
        // ... more validation

        // Processing logic (30 lines)
        if (component.getType().equals("TEXT")) {
            // Text processing
        } else if (component.getType().equals("MEDIA")) {
            // Media processing
        }
        // ... more processing

        // Persistence logic (20 lines)
        try {
            database.save(component);
            logger.info("Saved component");
        } catch (Exception e) {
            logger.error("Save failed", e);
        }
    }
}

// AFTER: Extracted methods with single responsibilities
public class InputComponentProcessor {
    private final ComponentValidator validator;
    private final ComponentProcessorFactory processorFactory;
    private final ComponentRepository repository;

    public void processComponent(Component component) {
        validator.validate(component);

        ComponentProcessor processor = processorFactory.getProcessor(component.getType());
        Component processedComponent = processor.process(component);

        repository.save(processedComponent);
    }
}

// Extracted validator
public class ComponentValidator {
    public void validate(Component component) {
        validateName(component.getName());
        validateType(component.getType());
        validateRequiredFields(component);
    }

    private void validateName(String name) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Component name is required");
        }
    }

    // Other validation methods...
}

// Strategy pattern for processing
public interface ComponentProcessor {
    Component process(Component component);
}

public class TextComponentProcessor implements ComponentProcessor {
    @Override
    public Component process(Component component) {
        // Text-specific processing
        return component;
    }
}
```

### 2. FirstSpirit Components → Proper Structure
```java
// BEFORE: Poor FirstSpirit component structure
public class MyInputComponent extends AbstractEditorValue {
    public void doEdit() {
        try {
            // 50 lines of mixed logic
            String value = getValue();
            if (value != null) {
                if (value.length() > 0) {
                    if (isValid(value)) {
                        SwingUtilities.invokeLater(() -> {
                            JDialog dialog = new JDialog();
                            // Complex UI creation inline
                            dialog.setVisible(true);
                        });
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();  // Poor error handling
        }
    }
}

// AFTER: Well-structured FirstSpirit component
public class MyInputComponent extends AbstractEditorValue {
    private static final Logger LOGGER = LoggerFactory.getLogger(MyInputComponent.class);

    private final ComponentUIFactory uiFactory;
    private final ValueValidator validator;

    @Override
    public void doEdit() {
        try {
            String currentValue = getCurrentValue();

            if (!hasValidValue(currentValue)) {
                showValueRequiredMessage();
                return;
            }

            openEditDialog(currentValue);

        } catch (ComponentException e) {
            LOGGER.error("Component edit operation failed", e);
            showErrorDialog(e.getMessage());
        } catch (Exception e) {
            LOGGER.error("Unexpected error during component edit", e);
            showUnexpectedErrorDialog();
        }
    }

    private String getCurrentValue() {
        Object value = getValue();
        return value != null ? value.toString() : "";
    }

    private boolean hasValidValue(String value) {
        return validator.isValid(value);
    }

    private void openEditDialog(String value) {
        SwingUtilities.invokeLater(() -> {
            JDialog dialog = uiFactory.createEditDialog(value);
            dialog.setVisible(true);
        });
    }

    private void showErrorDialog(String message) {
        // Proper error dialog
    }
}
```

### 3. Exception Handling → Specific Exceptions
```java
// BEFORE: Generic exception handling
public void saveComponent(Component component) throws Exception {
    try {
        database.save(component);
    } catch (Exception e) {
        throw new Exception("Save failed");
    }
}

// AFTER: Specific exception hierarchy
public class ComponentException extends Exception {
    public ComponentException(String message, Throwable cause) {
        super(message, cause);
    }
}

public class ComponentValidationException extends ComponentException {
    public ComponentValidationException(String message) {
        super(message, null);
    }
}

public class ComponentPersistenceException extends ComponentException {
    public ComponentPersistenceException(String message, Throwable cause) {
        super(message, cause);
    }
}

public void saveComponent(Component component) throws ComponentException {
    try {
        validator.validate(component);
        database.save(component);
    } catch (ValidationException e) {
        throw new ComponentValidationException("Component validation failed: " + e.getMessage());
    } catch (DatabaseException e) {
        throw new ComponentPersistenceException("Failed to save component", e);
    }
}
```

### 4. Builder Pattern for Complex Objects
```java
// BEFORE: Constructor with many parameters
public class FirstSpiritModule {
    public FirstSpiritModule(String name, String version, String description, List components,
                           Map properties, boolean enabled, String author, Date created) {
        // Constructor with too many parameters
    }
}

// AFTER: Builder pattern
public class FirstSpiritModule {
    private final String name;
    private final String version;
    private final String description;
    private final List components;
    private final Map properties;
    private final boolean enabled;
    private final String author;
    private final Date created;

    private FirstSpiritModule(Builder builder) {
        this.name = builder.name;
        this.version = builder.version;
        // ... other assignments
    }

    public static class Builder {
        private String name;
        private String version;
        private String description = "";
        private List components = new ArrayList<>();
        private Map properties = new HashMap<>();
        private boolean enabled = true;
        private String author = "";
        private Date created = new Date();

        public Builder name(String name) {
            this.name = name;
            return this;
        }

        public Builder version(String version) {
            this.version = version;
            return this;
        }

        // Other builder methods...

        public FirstSpiritModule build() {
            validateRequiredFields();
            return new FirstSpiritModule(this);
        }

        private void validateRequiredFields() {
            if (name == null || name.trim().isEmpty()) {
                throw new IllegalStateException("Module name is required");
            }
            if (version == null || version.trim().isEmpty()) {
                throw new IllegalStateException("Module version is required");
            }
        }
    }
}

// Usage
FirstSpiritModule module = new FirstSpiritModule.Builder()
    .name("My Module")
    .version("1.0.0")
    .description("A sample module")
    .enabled(true)
    .build();
```

## JAVA QUALITY RULES

### Class Design Rules
- **Single Responsibility**: Each class should have one reason to change
- **Maximum methods**: 15-20 public methods per class
- **Composition over inheritance**: Prefer composition for flexibility
- **Immutable objects**: Make objects immutable when possible

### Method Rules
- **Maximum lines**: 20-30 lines per method
- **Maximum parameters**: 4-5 parameters (use objects for more)
- **Meaningful names**: Method names should clearly describe their purpose
- **Exception handling**: Use specific exceptions with meaningful messages

### FirstSpirit-Specific Rules
- **Proper inheritance**: Extend correct FirstSpirit base classes
- **Resource management**: Always close FirstSpirit resources
- **Thread safety**: Handle concurrent access properly
- **Error logging**: Use SLF4J for consistent logging
