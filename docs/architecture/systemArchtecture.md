System Architecture: LTMC1. Architectural ModelThe system will be implemented as a Layered Monolithic Application. This model provides a clear separation of concerns, making it easy to develop, test, and maintain, while avoiding the complexity of a microservices architecture at this stage.The application is divided into four distinct layers:1.1. API Layer (Presentation)Responsibility: Handles all incoming HTTP requests and outgoing responses. This is the sole entry point for external clients.Components: FastAPI routers, Pydantic models for request/response validation and serialization.Rules: This layer contains no business logic. Its only job is to validate data, call the appropriate service layer function, and format the response.1.2. Service Layer (Business Logic)Responsibility: The brain of the application. It orchestrates all core processes, such as chunking text, generating embeddings, and linking resources to chats.Components: Service classes or modules (e.g., ResourceService, ContextService).Rules: It coordinates calls between the Data Access Layer and the Vector DB Abstraction to fulfill a use case. It is unaware of HTTP; it deals in pure data objects.1.3. Data Access Layer (Persistence)Responsibility: Manages all interactions with the persistent storage systems. It abstracts the underlying databases from the rest of the application.Components:Relational DAL: A module containing functions for all CRUD (Create, Read, Update, Delete) operations on the SQLite database.Vector DB Abstraction: A class-based wrapper around the FAISS library for all vector operations (add, search, save, load).Rules: This layer contains only the logic required to talk to the databases. It does not know why it's being asked to fetch or store data.1.4. Core / Config LayerResponsibility: Manages application-wide concerns.Components:Configuration: A module to load settings from environment variables.Lifecycle Management: Functions to handle application startup (e.g., loading the embedding model, initializing the FAISS index) and shutdown (e.g., saving the index to disk).Singleton Clients: Initializes and provides access to shared clients like the embedding model.
