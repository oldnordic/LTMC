Dataflow: LTMCDataflow 1: Ingesting a New Resource (Document/Code)This flow describes the process of adding a new piece of information to the system's memory.Client Request: An external client sends a POST request to the /api/v1/resources endpoint with a JSON payload containing file_name, type, and content.API Layer: The endpoint receives the request. The Pydantic model validates the incoming data structure and types.Service Call: The API layer calls the resource_service.add_resource() function, passing the validated data.Chunking: The ResourceService calls a ChunkingService to break the raw content into smaller, semantically coherent chunks.Embedding: The ResourceService iterates through the chunks and calls the EmbeddingService for each one to generate a vector embedding.Database Storage: The ResourceService calls the database.dal module to:a. Create a new entry in the Resources table for the parent file.b. Create entries in the ResourceChunks table for each text chunk, storing the text and reserving a unique vector_id.Vector Storage: The ResourceService calls the vector_store.add() method, passing the list of new embeddings and their corresponding vector_ids. The vector store adds these to the FAISS index.API Response: The service returns a success confirmation to the API layer, which then sends an HTTP 201 Created response to the client with the new resource_id.Dataflow 2: Retrieving Context for a Chat QueryThis flow describes how the system recalls relevant information to answer a new query.Client Request: A client sends a POST request to /api/v1/context with a JSON payload containing the conversation_id and the user's query.API Layer: The endpoint validates the incoming query using its Pydantic model.Service Call: The API layer calls the context_service.get_context_for_query() function.Query Embedding: The ContextService calls the EmbeddingService to generate a vector embedding for the user's query.Similarity Search: The ContextService calls vector_store.search(), passing the query vector. FAISS returns a list of the vector_ids for the top 'k' most similar chunks.Retrieve Full Text: The ContextService passes these vector_ids to the database.dal to fetch the original text of the corresponding chunks from the ResourceChunks table.Log Interaction: The ContextService calls the database.dal to:a. Log the new user query in the ChatHistory table.b. For each retrieved chunk, create a link in the ContextLinks table connecting the new chat message to the chunk that was used as context.Assemble Context: The service combines the retrieved text chunks into a single, formatted string.API Response: The service returns the assembled context block to the API layer, which sends an HTTP 200 OK response to the client.
